### Правила написания кода для backend-разработчиков:

## Проект для серверной части поделен на несколько слоев (namespace): 

 - DataAccess - работа с базой данных, подключение к ней, модели для БД, контекст, репозитории, миграции; 

 - Models - модели, которые используются для преобразования моделей из БД и отправки на фронт, также различные Request и Response модели;

 - Services - работа с соотв. репозиториями и другими сервисами, перенаправление и обработка вызовов контроллеров. Также в этом слое расположены классы-мапперы для преобразования моделей БД в модели для фронта и наоборот;

 - Controllers - контроллеры, через которые идут запросы к серверной части. Взаимодействуют с сервисами



## При написании кода необходимо: 

 - Стремиться к взаимодействию компонентов между собой с помощью интерфейсов, т.е.: контроллеры взаимодействуют с интерфейсами соответствующих сервисов, сервисы взаимодействуют с интерфейсами других сервисов и репозиториев. Это необходимо для разделения реализации действий от результата действий: мы в любой момент можем изменить реализацию метода, реализовав интерфейс по-другому.

 - Реализовывать обработку исключений через try-catch, а также в принципе строить логику так, чтобы обрабатывать наибольшее количество различных кейсов.

 - Стремиться к использованию подхода KISS («Keep it simple, stupid» — «Делай проще, тупица»), т.е. не использовать длинные методы, стремиться к декомпозиции. Лучше много маленьких методов, которые в будущем можно переиспользовать, чем один большой, который необходим лишь для 1 кейса. Это же относится к классам, к общей логике работы системы.

 - Стремиться к использованию подхода DRY («Don't repeat yourself» — «Не повторяйся»), т.е. выносить общую логику за пределы метода, чтобы ее было проще переиспользовать. Это же относится к классам, к общей логике работы системы.

 - Стремиться к использованию подхода SOLID («single responsibility, open–closed, Liskov substitution, interface segregation, dependency inversion»), т.е.:

   S - Делать классы, ответственные за 1 задачу. Пример: UserRepository - работа ИСКЛЮЧИТЕЛЬНО c классом User и DbUser с точки зрения данных: crud, взаимодействие с контекстом БД. Все. Он не должен выполнять различную логику по какой-то обработке действий, это задача сервисов, как и взаимодействовать с другими репозиториями.
   
   O - «Программные сущности (классы, модули, функции и т. п.) должны быть открыты для расширения, но закрыты для изменения», т.е. поведение сущности может быть расширено путём создания новых типов сущностей, но в результате расширения поведения не должны вноситься изменения в код, который эту сущность использует.
   
   L - «Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом». Для этого мы работаем с интерфейсами, см. выше.
   
   I - «Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения». Для этого см пункт для S + пункт для KISS выше.
   
   D - «Зависимость на Абстракциях. Нет зависимости на что-то конкретное». Для этого мы работаем с интерфейсами, см. выше



## Конкретные правила и ограничения:
 
 - Все определения свойств, методов, классов, перечислений, событий, делегатов и структур, интерфейсов описываются Pascal casing. Пример: UserController, GetUser, CreateUserRequest;

 - Локальные переменные, аргументы методов и защищенные поля описываются Camel casing. Пример: var user = GetUser(int userId);

 - Имена пользовательских классов исключений всегда заканчиваются суффиксом «Exception». Пример: создание спец. класса EntityNotFoundException;

 - Имена интерфейсов всегда начинаются с префикса «I». Пример: IUserService, IUserRepository;

 -  Для именования методов использовать конструкцию глагол-объект. Пример: GetUser, DeleteRecipe. Также для возвращающих значение методов нужно использовать глагол «Get»;

 - Обявление переменной начинать со слова «var»;

 - Фигурные скобки всегда располагать на новой строке;

 - Вместо условия if на одну строку использовать тернарный оператор. Пример: userId == default ? Task.FromResult(new User()) : GetUser(int userId), т.е. если айди существующий, то достаем юзера из базы, если нет - возвращаем юзера без данных
